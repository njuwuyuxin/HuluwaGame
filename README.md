## 葫芦娃游戏
### 开发环境
- IDE：IntelliJ 2019.2.2 x64
- JDK 8
- 构建工具：Maven

### 总体设计
- 本葫芦娃游戏主要实现了两名玩家联网对战，游戏类型为回合制战棋，双方交替进行操作，每一回合可操作一名角色进行移动、攻击。先将对方全部角色消灭的一方获得胜利。
- 网络部分主要使用P2P架构，由一名玩家作为服务器（主机），另一名玩家作为客户端（客机），不需要额外服务器维护客户端状态。
- 目前实现局域网内对战，如要公网对战需要机器具有公网IP

### 设计模式
#### 单例模式
本项目中为了管理联网对战中不同玩家状态，统一管理游戏流程及进行状态，创建了GameManger单例。
GameManager使用了**饿汉模式**，私有化构造函数的同时，在类加载时自动初始化实例。主要为了避免在多线程情况下可能会出现的线程不安全情况。
GameManager实例主要用于维护以下几个模块及状态：
- NetClient模块：网络模块，负责两个玩家之间连接的建立及网络数据传输
- 回合状态：负责同步两玩家之间回合状态，控制玩家操作权限
- 阶段状态：负责控制每个玩家在自己回合中的不同阶段（移动阶段、攻击阶段）

### 网络设计
#### 网络流程设计
网络部分主要由NetClient模块控制，在该模块初始化后，可选择以服务端模式或客户端模式创建，网络传输使用TCP协议
- 服务端模式：以服务端模式创建，会随机选择本机可用端口，开启监听其他客户端的连接请求
- 客户端模式：以客户端模式创建，需要手动输入要连接的服务端ip及端口号，发起连接请求
- 连接建立后，NetClient模块启动发包和收包线程，进行网络数据传输
#### 网络协议设计
...

### 多线程设计
#### JavaFX线程
- JavaFx线程作为整个程序的主线程，用来控制游戏的正常流程，及UI界面的更新等
- 但游戏运行时有时需要等待对方传来数据后才能进行下一步操作，为了避免主线程阻塞出现未响应情况，需要在其他线程中更新游戏状态及界面UI。
- 但由于JavaFx限定UI操作只能在JavaF线程中操作，因此这里使用了JavaFx的concurrent库中的Task来实现多线程相关操作
- Task的主要功能如下
  ```
  class ReceiveMsgTask extends Task<Void>{
        @Override
        protected synchronized Void call() throws Exception {
            //用于进行某些耗时操作，这些操作会在开启的新线程中进行，避免主线程阻塞
            return null;
        }

        @Override
        protected synchronized void succeeded(){
            //在Task执行完毕后会进行调用，这部分调用在主线程中完成，因此可用于UI更新等操作
        }
    }
  ```
- 使用Task，我们便可以为某些耗时或需要等待的任务创建一个Task，开启一个新线程执行，同时可以保证在任务完成时触发succeeded回调函数，在主线程中对UI进行更新。在本项目中，等待对方回合、回放操作均使用了Task进行实现，保证了UI实时更新的同时不会阻塞主线程。

#### 网络线程
在服务端与客户端建立连接后，NetClient模块启动两个线程，分别负责收包和发包，保证数据的实时性。
- 发包线程维护一个消息队列，由主线程向队列填充待发送数据，发包线程在空闲时依次发送数据
- 收包线程同样维护一个消息队列，时刻监听对方发来的数据包并存入消息队列，待主线程需要时，从消息队列中依次取出数据
- 两个消息队列均使用了互斥锁保证线程安全，同一时间，同一消息队列，只有一个线程可进行访问

#### 日志线程

### 回放设计
#### 数据结构及序列化设计

#### 回放逻辑
回放部分首先读取本地记录的对战数据文件，将其反序列化为程序存储的数据结构，存放与回放队列中，按步进行回放，可控制回放每步之间的时间间隔。
- 读取数据后，在主界面初始化时开始回放
- 由于JavaFX的UI刷新机制，每个事件处理函数返回后才可对界面进行刷新，并未提供类似repaint()之类的主动刷新方法，因此无法在一个主循环中按步进行回放（会导致UI卡死得不到刷新，只有所有步骤回放完毕后才会一次性刷新）
- 因此这里使用Task进行单步回放操作，即每一步回放操作均创建一个新Task进行执行，由于该Task在新创建的线程中执行，主线程可以及时返回，从而保证了UI的及时刷新。 在每一个单步回放Task执行完毕后，在succeeded回调中检测回放队列中是否还有指令，如果有，则取出下一条指令，创建新的Task线程进行执行。整个过程为**跨线程递归**模式，直到回放队列数据均被执行完毕，回放结束。
