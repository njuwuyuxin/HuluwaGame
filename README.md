## 葫芦娃游戏

> 作者：
>
> 吴雨昕 161290019
>
> * 主要负责游戏框架设计、流程设计，多线程结构设计、游戏UI界面搭建，以及回放功能实现
>
> 闫煜婷  171098043
>
> * 主要负责游戏后端数据设计（人物、战场的设计及为主逻辑提供接口）、网络协议和通信接口设计、游戏日志记录，少量参与图形化界面设计

[toc]

### 开发环境

- IDE：IntelliJ 2019.2.2 x64
- JDK 8
- 构建工具：Maven

## 总体设计
- 本葫芦娃游戏主要实现了两名玩家联网对战，游戏类型为回合制战棋，双方交替进行操作，每一回合可操作一名角色进行移动、攻击。先将对方全部角色消灭的一方获得胜利。
- 网络部分主要使用P2P架构，由一名玩家作为服务器（主机），另一名玩家作为客户端（客机），不需要额外服务器维护客户端状态。
- 目前实现局域网内对战，如要公网对战需要机器具有公网IP。

### 后端数据设计

#### 人物

<img src="https://gitee.com/yyt1218/tuchuang/raw/master/img/fighter.png" alt="fighter" style="zoom:67%;" />

设计了抽象类Fighter作为所有战斗角色的父类，衍生出葫芦娃、爷爷、蛇精、蝎子精、喽啰类。

采用设计模式中的工厂模式完成对象的创建。

* 设计了FighterFactory接口，接口中定义了枚举类型FighterType，用来标注要生成哪种战斗角色。其中进一步设计了各种不同的葫芦娃，让不同葫芦娃拥有不同的属性。接口中定义了`create`方法用于角色生成。
  * 攻击型葫芦娃：攻击高，hp和防御低
  * 防御型葫芦娃：攻击低，hp和防御高，移动速度慢
  * 速度型葫芦娃：攻击防御均衡，移动速度快，射程长

* 定义了HumanFactory和MonsterFactory类继承FighterFactory接口，输入不同的FighterType，返回对应的角色对象。这样做的好处在于调用者无需知道战斗角色对象的细节，当战斗角色的基础属性需要修改时也无需更改调用端。

设计了FighterList类存储某一阵营的战斗角色队伍，并判断队伍中是否还有活着的角色，来作为游戏结束的基础判断。FighterList类实现了Iterable接口，来实现对战斗队伍的遍历。

#### 战场

定义BattleGround类作为战场，战场采用了饿汉模式，核心内容是一个10*10的数组格子，并在每个格子里存储了站在这个格子上的对象，设计了`getFighterOn`方法来快速获取站在某个位置的对象。并配合游戏玩法，设计了移动对象到某格子、删除某格子上的对象等方法。

### 游戏控制台设计
本项目中为了管理联网对战中不同玩家状态，统一管理游戏流程及进行状态，创建了GameManger单例。
GameManager使用了**饿汉模式**，私有化构造函数的同时，在类加载时自动初始化实例。主要为了避免在多线程情况下可能会出现的线程不安全情况。
GameManager实例主要用于维护以下几个模块及状态：
- NetClient模块：网络模块，负责两个玩家之间连接的建立及网络数据传输
- 回合状态：负责同步两玩家之间回合状态，控制玩家操作权限
- 阶段状态：负责控制每个玩家在自己回合中的不同阶段（移动阶段、攻击阶段）
- 战斗队伍：存储双方的战斗队列FighterList和其中的战斗角色，用于获取战斗角色状态、判断队伍是否全部阵亡/战斗是否结束。

### 网络设计
#### 网络流程设计
网络部分主要由NetClient模块控制，在该模块初始化后，可选择以服务端模式或客户端模式创建，网络传输使用TCP协议
- 服务端模式：以服务端模式创建，会随机选择本机可用端口，开启监听其他客户端的连接请求
- 客户端模式：以客户端模式创建，需要手动输入要连接的服务端ip及端口号，发起连接请求
- 连接建立后，NetClient模块启动发包和收包线程，进行网络数据传输
#### 网络协议设计

![Msg](https://gitee.com/yyt1218/tuchuang/raw/master/img/Msg.png)

为了完成P2P的信息交换，设计了接口Message，又设计了三种不同类型的消息实现该接口。为了对战斗过程进行记录，Message接口继承了接口Serializable，通过将收到和发出的每条Message写入存档文件中，即可完成战斗记录。

Message接口中定义了一个枚举类型Kind，用来代表信息的种类。实现接口Message需要实现`getKind()`方法，返回当前信息的种类。

* AttackMsg用于发送一条攻击信息，内容为<fromX, fromY, toX, toY, fromId, toId>，包括攻击者的id，攻击者坐标，被攻击者坐标。
* MoveMsg用于发送一条移动信息，内容为<id, fromX, fromY, toX, toY>，包括发起移动的人物id，原位置坐标，新位置坐标
* EndMsg用于发送一条行动阶段结束信息，没有内容，代表跳过当前的移动/攻击阶段，进入下一阶段，或进入对手回合。

### 多线程设计
#### JavaFX线程
- JavaFx线程作为整个程序的主线程，用来控制游戏的正常流程，及UI界面的更新等
- 但游戏运行时有时需要等待对方传来数据后才能进行下一步操作，为了避免主线程阻塞出现未响应情况，需要在其他线程中更新游戏状态及界面UI。
- 但由于JavaFx限定UI操作只能在JavaF线程中操作，因此这里使用了JavaFx的concurrent库中的Task来实现多线程相关操作
- Task的主要功能如下
  ```java
  class ReceiveMsgTask extends Task<Void>{
        @Override
        protected synchronized Void call() throws Exception {
            //用于进行某些耗时操作，这些操作会在开启的新线程中进行，避免主线程阻塞
            return null;
        }

        @Override
        protected synchronized void succeeded(){
            //在Task执行完毕后会进行调用，这部分调用在主线程中完成，因此可用于UI更新等操作
        }
    }
  ```
- 使用Task，我们便可以为某些耗时或需要等待的任务创建一个Task，开启一个新线程执行，同时可以保证在任务完成时触发succeeded回调函数，在主线程中对UI进行更新。在本项目中，等待对方回合、回放操作均使用了Task进行实现，保证了UI实时更新的同时不会阻塞主线程。

#### 网络线程
在服务端与客户端建立连接后，NetClient模块启动两个线程，分别负责收包和发包，保证数据的实时性。
- 发包线程维护一个消息队列，由主线程向队列填充待发送数据，发包线程在空闲时依次发送数据
- 收包线程同样维护一个消息队列，时刻监听对方发来的数据包并存入消息队列，待主线程需要时，从消息队列中依次取出数据
- 两个消息队列均使用了互斥锁保证线程安全，同一时间，同一消息队列，只有一个线程可进行访问

### 回放设计

设计了GameLogger类用于记录和从文件中读取游戏日志。GameLogger采用懒汉模式，只有当需要记录数据的时候才初始化GameLogger对象，这样在没有进行游戏时（如只用了回放模式）就不会留下空的存档数据。

GameLogger类包括一个File对象和一个ObjectOutputStream对象，在初始化时会在主目录的saves/文件夹下生成新的存档文件，命名为\<time\>.save，并打开一个输出流对象。

#### 序列化设计

为了对战斗过程进行记录，Message接口继承了接口Serializable，通过将收到和发出的每条Message写入存档文件中，即可完成战斗记录。

在每次收包、发包时调用`GameLogger.log(Message)`方法进行message的记录，将当前Message写入到存档文件中。

#### 回放逻辑
回放部分首先读取本地记录的对战数据文件，将其反序列化为程序存储的数据结构，存放与回放队列中，按步进行回放，可控制回放每步之间的时间间隔。
- 读取数据后，在主界面初始化时开始回放
- 由于JavaFX的UI刷新机制，每个事件处理函数返回后才可对界面进行刷新，并未提供类似repaint()之类的主动刷新方法，因此无法在一个主循环中按步进行回放（会导致UI卡死得不到刷新，只有所有步骤回放完毕后才会一次性刷新）
- 因此这里使用Task进行单步回放操作，即每一步回放操作均创建一个新Task进行执行，由于该Task在新创建的线程中执行，主线程可以及时返回，从而保证了UI的及时刷新。 在每一个单步回放Task执行完毕后，在succeeded回调中检测回放队列中是否还有指令，如果有，则取出下一条指令，创建新的Task线程进行执行。整个过程为**跨线程递归**模式，直到回放队列数据均被执行完毕，回放结束。

## 游戏方法

#### 进行游戏

<img src="https://gitee.com/yyt1218/tuchuang/raw/master/img/image-20210102184954274.png" alt="image-20210102184954274" style="zoom:80%;" />

点击开始游戏，会弹出网络连接窗口，左侧显示本机IP和端口，右侧显示要连接的目标主机IP和端口。A点击创建服务器端，并将本机IP和端口告知B；B在右侧输入对方的IP和端口，并点击创建客户端，即可建立连接。（默认为测试模式，ip为本机ip）

进入游戏后，葫芦娃方先开始行动。每回合分为移动阶段和攻击阶段，移动阶段点击己方人物显示移动范围，点击绿色格子移动到对应格子。攻击阶段点击己方人物显示攻击范围，点击红色格子内的人物进行攻击。也可以点击右侧按钮，跳过当前移动或攻击阶段（如攻击范围内没有敌方对象）。攻击阶段结束后，本回合结束，对方回合开始。

点击己方或敌方人物，画面右侧会显示人物当前的血量、攻击、防御、移动、攻击范围等能力。

#### 存档回放

点击存档回放，选择以.save结尾的存档文件后，自动开始回放战斗。提交的存档文件为主目录的*saves/战斗记录.save*文件。

